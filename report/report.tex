\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{a4paper, bottom=20mm, top=30mm, left=15mm, right=15mm}
\usepackage{pdfpages}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength{\parindent}{0cm}
\setlength{\headheight}{14pt}
\usepackage{tocloft}
\usepackage{parskip}
\usepackage[export]{adjustbox}
\usepackage{float}
\usepackage{subfig}
\usepackage{graphicx}
\graphicspath{{../figures}}
\usepackage{amsmath,blkarray,booktabs,bigstrut, amssymb}
\usepackage{pythonhighlight}
\usepackage{outlines}
\usepackage{soul}
\usepackage[hidelinks]{hyperref}
\usepackage[backend=biber, style=ieee]{biblatex}
\addbibresource{references.bib}
\defbibheading{bibliography}{} % Hides the "References" title
\usepackage{url}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}
\widowpenalty10000
\clubpenalty10000
\setcounter{secnumdepth}{3}
\usepackage[newfloat]{minted}
\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Code Listing}
 
\begin{document}

\newgeometry{top=20mm}
\begin{titlepage}
    \begin{center}
      \begin{figure}
        \includegraphics[right]{logo.png}
      \end{figure}
      \vspace*{1cm}
      \textsc{\large ENEL373: Digital Electronics and Devices}\\[0.5cm]
      \textsc{\Large University of Canterbury}\\[3.5cm]
      \linespread{1}
      {\Huge\bfseries{Development of a Reaction \\[0.3cm] Timer in VHDL}} \\
      \vspace*{2cm}
      {\Huge Philip Brand \textit{\Large(15776928)}\\\par}
      {\Huge Michael Brown \textit{\Large(48571923)}\\\par}
      {\Huge Boston Black \textit{\Large(24668421)}\\\par}
      \vspace*{3cm}
      {\LARGE \today}
    \end{center}
  \end{titlepage}
\restoregeometry

\fancyhead{}
\fancyhead[L]{\small{ENEL373 - Reaction Timer Project}}
\fancyhead[R]{\small{\today}}

\pagenumbering{roman}

\renewcommand{\baselinestretch}{1.3}\normalsize
\setlength{\cftbeforesecskip}{0.3em}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\addcontentsline{toc}{section}{Contents}
\tableofcontents\thispagestyle{fancy}
\renewcommand{\baselinestretch}{1}\normalsize

\newpage
\pagenumbering{arabic}

\section{Introduction}
% Outline (in your own words) the project requirements and what you achieved

Human reaction time is the interval between a stimulus, and the response to that stimulus. There are two main types of reaction time; simple, and choice. Simple reaction involves reacting to a singular stimulus, while choice reaction involves choosing the correct response from multiple stimuli. This project aims to implement a simple reaction time recorder on an FPGA in VHDL.

The reaction stimulus test starts with three LCD dots that turn off sequentially, with a random delay. Once the last dot turns off, the user must press a button to stop the test. The delay is then displayed on 8 7-segmant displays. The FPGA stores the reaction delays from the last three trials, and can display the fastest, slowest, and average reaction time2. The times can be cleared by the user.

This report outlines the implementation of the reaction timer, along with the design methods used, testing of some of the modules, and issues encountered during the project.

\section{Design Summary}
% Summarise your design.

The FPGA reaction stimulus prompt and response recording depends on four major components. The eight-digit counter, the ALU, the reaction countdown, and the output select and override. These components are shown in Figure \ref{project_structure}. Each of these components are enabled and disabled via a finite state machine.

% TODO: Add an error state module/mux to the diagram
% TODO: Add better labels to diagram
\begin{figure}[H]
  \centering
  \includegraphics[width=0.66\textwidth]{project_overall_structure.png}
  \caption{Overview of VHDL reaction timer structure}
  \label{project_structure}
\end{figure}

An eight-digit five-bit-BCD counter is the primary mechanism for keeping track of the reaction time in milliseconds for each stimulus test. Each BCD digit is passed into an 8x5-to-5 multiplexer. The purpose of this multiplexer is to synchronise the selected output digit with the seven segmant display meaning each digit is displayed on its respective display.

All BCD digits from the eight-digit counter are passed through the bcd\_8\_to\_binary module, which converts the BCD number into a 28-bit binary number. This binary number is then passed into a circular buffer, which stores reaction time data. The ALU reads the circular buffer to calculate the average, minimum, and maximum of the last three reaction times. These times are converted back into BCD using the double dabble algorithm \cite{double_dabble}. Finally, another 8x5-to-5 multiplexer is used to select which digit is output to the display.

A linear feedback shift register is used to provide randomisation for each reaction stimulus countdown sequence. This shift register sets the upperbound for a clock divider, whose output triggers the shift register to change its pseudorandom output. The clock divider triggers each LCD dot during the countdown state, named doitey. The dots are piped onto the seven segment display using a 8x5 5-bit multiplexer.

All three 8x5-to-5 multiplexers from the three components described above are piped into another 8x5-to-5 multiplexer used for seven segment output selection. This multiplexer selects which module to output depending on the active state. The multiplexer output is piped into a text override, which overwrites some of the digits with letters based on the active state. This is finally piped into the 7 segment decoder, which takes a five-bit BCD digit and converts it to a eight-bit seven segment display light combination which is piped to hardware.

\section{Expanded Design Summary}
% (~2 pages): Describe the methods your group used to implement your FPGA design. Justify your final design. Support your descriptions and justifications with specific, explicit references to your VHDL source code in the appendix. VHDL descriptions could, for example, include an RTL description. 

\subsection{Design Methods}

The primary focus for the reaction timer project project was to develop VHDL code that is easy to maintain and further develop. This led to a heavy focus on modular design and code reuse. Since the project was developed as a group, the other focus was for modules to be developed and tested individually, and then put together with minimal issues.

\subsubsection{Diagramming}

\hl{Michael to scan one of his drawings and add reference in following paragraph.}
% TODO: add paper diagram

The primary program development method used in this project was to draw program or module flow diagrams before VHDL was written. These digrams detailed the communication between between individual modules, and outlined the overall program structure. Figure \ref{paper} shows \dots

Clear communication of the expected inputs and outputs from each module between group members played a significant role in keeping the final assembly simple. \hl{One example of standard inputs/outputs is the use of 5-bit BCD for all communication of characters or numbers. The only place 5-bit BCD was not used for numbers was the ALU.} $\leftarrow$ Is this better?

\subsubsection{Naming and Syntax Conventions}

Another important aspect of the project ensuring high code quality, readability, and maintainability was strict rules around naming and syntax. This included consistent whitespace, indentation, case, and naming style. 

For example, all signals within an entity were postfixed with an underscore, and whether that signal was an input or output. This can be seen in Code Listing \ref{code:entity_naming_convention} in Appendix A. This ensured when the modules were used in the top-level Behavioural architecture with port mapping, it was easy to see which signals were inputs and outputs.

To make the difference between port and internal signals clear, port names were in all capitals, while internal signals were in all lowercase. The signal types were also capitalised for ports, e,g. STD\_LOGIC, instead of std\_logic. This can be seen in Code Listings \ref{code:case_io} and \ref{code:case} in Appendix A.

When naming modules, an effort was made to name them in a way that described the capabilities of the module. For example,  timer\_8\_num\_selectable has eight numbers and one can be selected. The postfix \_xb was used to indicate a module had an x bit input/output. This is used in modules such as counter\_3b and decoder\_3b.

\subsubsection{Module Reuse}

In order to reduce the number of modules needed to be created and maintained, modules were reused where possible. The most versatile example of this was the eight-channel five-bit multiplexer shown in Code Listing \ref{code:8x5_to_5_multiplexer} in Appendix A. The multiplexer took up to eight five-bit BCD inputs, and selected one of those to be output. \textit{The select lines and number of channels for the multiplexer corresponded with the segment display, allowing both to be controlled with the same signal}. This capability made the multiplexer easy to use for displaying timer digits and error message characters. The same multiplexer was also used to select what output to pipe to the segment display, depending on the state. While not all multiplexer channels were used in all instantiations, using the same module in all instances was logical as the module was known to work and integrate well with other modules.

Another frequently reused module was the clock divider. The wide use of the module was aided by the ability for the upperbound to be set by an input rather than being hard-coded within the module, and the ability for upperbound to be updated during module use.  For example, the pseudorandom dot delay used the same clk\_divider module as real-time upperbound changes resulted in different clock speeds and therefore delays.

\subsubsection{Programming Techniques}

Another method used to implement the FPGA design was pair programming. This had to be done with care as, with three people working on the project, it would have been easy to leave one person out of the process resulting in them lacking understanding of the code. However, pair programming did help ensure that minimal time was spent debugging, as the observer frequently caught subtleties of VHDL that the programmer missed. Pair programming was used to develop the circular buffer, counters, and FSM.

Since the project was significantly modularised, it was important that individual modules could be developed and tested without hindering the development of other modules. The method used to achieve this was git branching and merging. Individual modules were developed on separate branches, tested, and then merged into the main branch. This ensured that the main branch was always stable, and that broken changes could be easily rolled back.

\subsection{Design Justification}

The reaction timer design is intended to allow easy modification or expansion. Keeping modularisation as a high priority during module design allowed each module to view the other modules as a ``black box'', only interacting with each other through standardised interfaces. These interfaces were typically a single custom five-bit BCD data line, and were controlled by the generalised 8x5-to-5 multiplexer shown in Appendix \ref{code:8x5_to_5_multiplexer}, reducing the required number of different modules. The only exception to the five-bit data line was the output of the BCD counter, which output eight five-bit data lines simultaneously to the BCD-to-binary converter, as the converter operated on all digits at once. These eight data lines were put into a bus, as shown in Code Listing \ref{code:bcd_to_binary} in Appendix A.

A second benefit of each module being a ``black box'' was that since most modules interacted through standardised interfaces, how the modules operated internally was irrelevant. This allowed for significant changes within a module to how a task was completed, without disturbing inter-module communication, or the operation of other modules.

The usage of the 8x5-to-5 multiplexer shown in Code Listing \ref{code:output_select_mux_instantiation} in Appendix A to select between outputs allows for addition of states as desired by utilizing more multiplexer inputs, with output select lines controlled by the finite state machine. If more states were to be added, then additional multiplexers can be linked up for more input lines. This shows clear capability for design expansion.

A selectively enabled text override module was used to display text on the first two seven-segment displays,  as this module centralised control of the text display. This further simplified other modules by limiting their design to numeric manipulation, rather than alphabetic or alphanumeric manipulation. 

% TODO: philip sir add justification of lfsr for randon number generation

\section{Module Testing}
% A brief section describing how you tested a significant module. Include at least one testbench and associated waveforms that demonstrate the functionality of a module in the report appendix.

% TODO: rename bcd_expanded_out, possibly remove just have a standard 4-bit output
% TODO: reorder waveform to be more logical - put alu output next to operation select and things like that, put clock at the top probably too
% TODO: add testbench waveform for BCD to binary converter

During development of the circular buffer, ALU, and associated data-type converters, the output numbers were too small. For example a minimum reaction time of 246 milliseconds would be displayed as 91 milliseconds. Since the delay would be displayed correctly immediate after a test, the problem lay somewhere within the \hl{blue} block in Figure \ref{project_structure}. An assumption was made that the BCD-to-binary converter would be fault-free, since the logic it required was simple. To determine in which module the problem lay, a testbench comprising of the circular buffer, ALU, and binary-to-BCD converter was created. The testbench simulated three write operations to the circular buffer, an ALU operation select, and a trigger for the binary to BCD double-dabble algorithm, followed by reset signal to the circular buffer and binary-to-BCD converter. The testbench stimulus VHDL is in Listing \ref{code:alu_testbench} in Appendix B.

The major values output by the testbench are the circular buffer contents, the ALU operation select, and the binary-to-BCD converted output. These waveforms, as well as the input waveforms such as the clock, circular buffer write, and resets can be seen in Figure \ref{fig:alu_testbench}. The bcd\_out signal in the figure is the output of the custom five-bit BCD, while the readable\_bcd is the four-bit equivalent used display the number for simple analysis.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{thing.jpeg}
  \caption{Reaction statistic calculation testbench.}
  \label{fig:alu_testbench}
\end{figure}

The first 750 ns of testbench simulation show the three write operations to the circular buffer. The three circular buffer outputs change exactly as expected, with each write operation setting a new value. The ALU operation select is 3 at 700 ns, and the ALU output is 00878000, which is the correct hexadecimal representation of the average of the two values in the circular buffer when the operation was selected. The ALU operation is then set to 1 at approximately 850 ns, and the ALU outputs the correct maximum time of 00ff000. The final ALU operation is 2 at approximately 950 ns, and the ALU outputs the correct minimum time of 0010001. The binary-to-BCD converter is also triggered at 950 ns, and once the algorithm has completed, the BCD output is 00065537, which the correct BCD representation of 0010001 in hexadecimal.

These waveforms indicated that the problem did not lie where expected, and that the problem must have been with the BCD-to-binary converter originally thought of as fault-free. Another testbench was created to test that converter, and, as expected, the converter did not convert correctly. This was rectified by modifying the multiplication factors of 10 from hexadecimal to binary. The fixed testbench waveform can be seen in Figure \ref{fig:correct_converter_tb}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{WhatsApp Image 2025-05-08 at 16.13.24}
  \caption{Corrected BCD to binary converter testbench.}
  \label{fig:correct_converter_tb}
\end{figure}

These waveforms show the five-bit BCD and equivalent readable four-bit BCD inputs from the counter being correctly converted to binary. The readable BCD input is 00001952, which is equivalent to 00007a0, the hexadecimal representation of 1952.

\section{Design \& Implementation Problems}
% Design and/or Implementation problems (can be a separate section or part of the Conclusion): marks for describing problems encountered, and explaining approach to solving them.
% NB: Marks do not depend on whether problems were solved or not, but on the process used.
% 4 marks

One issue that arose during the development of the seven segment display module which mapped a BCD input to a combination of segments on a display to represent that BCD number was that the provided mappings did not represent the numbers correctly. The solution approach was to first determine whether the BCD input or mapping was incorrect. This was done by tying the BCD input to the green LEDs on the FPGA. This asserted BCD input was correct. To rectify the incorrect mappings, individual segments on a display were tied to the FPGA user switches. Combinations of switches were tested, and when the segments represented a number, the combination of switches was recorded as a BCD mapping.

However, once all the mappings were implemented, we found that our countdown timer failed to display the dots. Alteration of the countdown timer to display temporary digits instead of dots revealed the countdown to be functional. Stepping through the code by hand revealed that, due to the use of the unfamiliar provided seven segment decoder, a line of code was overlooked that overwrote the decimal place value. Disabling this line of code allowed the countdown timer to show dots.

A significantly unexpected issue that appeared during the testing of the finite state machine was deemed as the ``Schrodinger's States'' problem. This originated from the FSM running lines of code designed to change states even while they were commented out. To narrow down the source of the bug, the FSM was reduced to only what was necessary to run a simple reaction timer test without any ALU or error message. From there, states were slowly added back into the FSM and were tied to LEDs that would light up when the new states were activated. This showed additional issues in which an LED would trigger, but the state change wouldn't complete. With the suspicion that a race condition was in play,the issue was fixed by removing the FSM inputs from the sensitivity list of the FSM process, instead tying it to a 10 kHz clock.

There were issues with the simulation software built into the Vivado toolchain. During the design and subsequent simulation of the BCD-to-Binary numeric converter, the Vivado simulator would stop the simulation at the beginning of the numeric conversion, but would not give an error message to indicate an issue. The issue was narrowed down to being a problem with the simulator itself when a bitstream was generated for the whole system so that the converter could be tested as part of the whole, and no issue was found.

Another issue that arose was regarding case sensitivity in VHDL. Although VHDL is not case sensitive, the constraints file is. Early on during the project, while developing the clock divider, the error message seen in Figure \ref{fig:error} was encountered. The approach to solving this problem was to ask the TAs in the lab what the message meant. However, they were unable to explain the meaning. From there, the clock divider code we wrote was thoroughly compared to the provided clock divider code, and every small difference tested to see if it repaired the error. This determined the issue to be the case of the clock input declared in entity of main module, as lowercase had been used rather than uppercase. This correct case can be seen in Listing \ref{code:morecase}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{error.png}
  \caption{Vivado error message regarding case sensitivity.}
  \label{fig:error}
\end{figure}

\section{Conclusions}
% Highlight any problems you encountered and how you solved them. Also discuss what you learned and give suggestions on how the project could be improved

% Project could be improved by allowing a non-fixed number of inputs to the ALU, so a more arbitrary number of results could be calculated
% Learnt how testbenches can be useful but have their limits as somethimes they have bugs which are not present when the code is run on hardware.

When developing the reaction timer, an number of problems were encountered. One of these involved the FSM changing states unexpectedly. To find the cause of this problem, the FSM was simplified to a minimal working version, then slowly expanded. Another problem where the display module did not show the correct numbers was solved by creeating a small program mapping switches to the BCD inputs of the display module. Both of these problems were solved by reducing the scope of the program allowing the problem to be found without confusing things with extra complexity. This method, as well as the use of testbenches was an effective way of finding problems in VHDL code.

Modularity was a major strength allowing new features to be integrrated easily with the rest of the project, and making it easy to make changes to a module without breaking everything else. The modularity also reduced the effort needed to make changes such as increasing the number of bits in the BCD signals as there are less seperate modules in which the change needs to be made.

The project could be expanded and improved by implementing the ALU in such a way that it could take an arbitrary amount of numbers as input then calculate the average, max, and min. Currently it is harcoded to only accept three numbers and each of the input number needs its own signal going into the ALU module. this doesn't really fit with the modularity of the rest of the project as the ALU would need significant changes to work with more than three numbers.

\newpage
% There is no need to include a full code listing in your report as your code will be submitted via eng-git. However, reference to a code snippet in an appendix is quite appropriate. Formal citations to books, web articles, open source VHDL code and other sources should be listed in a reference section that uses the IEEE style and format.

\section{References}
\printbibliography

\newpage

\section{Appendix A: Code Listings}

\begin{code}
  \begin{minted}{vhdl}
  
    -- Define module IO
    entity counter_decade is
        Port ( EN_IN : in STD_LOGIC;
               RESET_IN : in STD_LOGIC;
               INCREMENT_IN : in STD_LOGIC;
               COUNT_OUT : out STD_LOGIC_VECTOR (3 downto 0);
               TICK_OUT : out STD_LOGIC);
    end counter_decade;

  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Entity naming example showing name post-fixes indicating data direction.}
  \label{code:entity_naming_convention}
\end{code}

\vspace*{1cm}

\begin{code}
  \begin{minted}{vhdl}
  entity clk_divider is
      Port ( CLK100MHZ_IN : in STD_LOGIC;
             UPPERBOUND_IN : in STD_LOGIC_VECTOR (27 downto 0);
             SLOWCLK_OUT : out STD_LOGIC);
  end clk_divider;

  architecture Behavioral of clk_divider is
    signal count: std_logic_vector (27 downto 0) := (others => '0');
    signal temp_clk: std_logic := '1';
    signal upperbound_half : std_logic_vector (27 downto 0);
  begin

  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Difference in case between port and internal signal type declarations.}
  \label{code:case_io}
\end{code}

\vspace*{1cm}

\begin{code}
  \begin{minted}{vhdl}
      entity counter_3b is
          Port ( CLK_IN : in STD_LOGIC;
                 COUNT_OUT : out STD_LOGIC_VECTOR (2 downto 0));
      end counter_3b;

      architecture Behavioral of counter_3b is
          signal count : std_logic_vector (2 downto 0) := (others => '0');
      begin

  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Difference in case between port and internal signal names.}
  \label{code:case}

\end{code}

\vspace*{1cm}

\begin{code}
  \begin{minted}{vhdl}
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    
    entity multiplexer_8_1_4b is
        Port ( MUX_IN_0 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_1 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_2 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_3 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_4 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_5 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_6 : in STD_LOGIC_VECTOR (4 downto 0);
               MUX_IN_7 : in STD_LOGIC_VECTOR (4 downto 0);
               SELECT_IN : in STD_LOGIC_VECTOR (2 downto 0);
               MUX_OUT : out STD_LOGIC_VECTOR (4 downto 0));
    end multiplexer_8_1_4b;
    
    architecture Behavioral of multiplexer_8_1_4b is
    begin
        process (SELECT_IN, MUX_IN_0, MUX_IN_1, MUX_IN_2, MUX_IN_3, MUX_IN_4, MUX_IN_5, MUX_IN_6, MUX_IN_7)
        begin
            case(SELECT_IN) is
                when "000" => MUX_OUT <= MUX_IN_0;
                when "001" => MUX_OUT <= MUX_IN_1;
                when "010" => MUX_OUT <= MUX_IN_2;
                when "011" => MUX_OUT <= MUX_IN_3;
                when "100" => MUX_OUT <= MUX_IN_4;
                when "101" => MUX_OUT <= MUX_IN_5;
                when "110" => MUX_OUT <= MUX_IN_6;
                when "111" => MUX_OUT <= MUX_IN_7;
            end case;
        end process;
    end Behavioral;
  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Generalised 8x5-to-5 mux.}
  \label{code:8x5_to_5_multiplexer}
\end{code}

\vspace*{1cm}

\begin{code}
  \begin{minted}{vhdl}
    entity bcd_8_to_binary is
        Port ( BCD_BUS_IN : in STD_LOGIC_VECTOR (39 downto 0);
              BINARY_OUT : out STD_LOGIC_VECTOR (27 downto 0));
    end bcd_8_to_binary;
  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{BCD to binary converter entity definition.}
  \label{code:bcd_to_binary}
\end{code}

\vspace*{1cm}

\begin{code}
  \begin{minted}{vhdl}
    ff11: multiplexer_8_1_4b port map (MUX_IN_0 => encoded_reaction_time_digit,
                                       MUX_IN_1 => selected_alu_bcd_digit,
                                       MUX_IN_2 => selected_alu_bcd_digit,
                                       MUX_IN_3 => selected_alu_bcd_digit,
                                       MUX_IN_4 => encoded_error_text,
                                       MUX_IN_5 => encoded_display_placeholder,
                                       MUX_IN_6 => encoded_display_placeholder,
                                       MUX_IN_7 => encoded_dots,
                                       SELECT_IN => encoded_display_input_select,
                                       MUX_OUT => encoded_segment_data);
  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Module instantiation of output select 8x5-to-5 mux.}
  \label{code:output_select_mux_instantiation}
\end{code}

\vspace*{1cm}

\begin{code}

  \begin{minted}{vhdl}
    entity main is
      Port ( CLK100MHZ : in STD_LOGIC;
            AN : out STD_LOGIC_VECTOR (7 downto 0) := X"00";
            SEVEN_SEG : out STD_LOGIC_VECTOR (7 downto 0) := X"00";
            BTNC : in STD_LOGIC;
            BTNR : in STD_LOGIC;
            BTNL : in STD_LOGIC;
            BTNU : in STD_LOGIC;
            BTND : in STD_LOGIC);  
    end main;
  \end{minted}
    \captionsetup{belowskip=0pt}
  \captionof{listing}{Correct case of port names in entity definition.}
  \label{code:morecase}
\end{code}

\newpage

\section{Appendix B: Testbench \& Waveforms}

\vspace*{1cm}
\begin{code}
  \begin{minted}{vhdl}
----------------------------------------------------------------------------------
-- Engineers: Michael Brown, Philip Brand
-- Create Date: 25.04.2025 02:04:31
-- Module Name: alu_setup_tb - Behavioral
-- Project Name: ALU Setup Test Bench 
-- Description: Tests the alu, circular_buffer, and binary_to_bcd_8 modules.
-- Additional Comments: Used to test the more complex parts of the 
-- reaction statistic calculations.
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity alu_setup_tb is
--  Port ( );
end alu_setup_tb;

architecture Behavioral of alu_setup_tb is
    signal circular_buffer_output_1 : std_logic_vector (27 downto 0) := (others => '0');
    signal circular_buffer_output_2 : std_logic_vector (27 downto 0) := (others => '0');
    signal circular_buffer_output_3 : std_logic_vector (27 downto 0) := (others => '0');
    signal circular_buffer_input : std_logic_vector (27 downto 0) := (others => '0');
    signal circular_buffer_size : std_logic_vector (1 downto 0) := (others => '0');
    signal alu_operation_select : std_logic_vector (1 downto 0) := (others => '0');
    signal circular_buffer_write_trigger : std_logic := '0';
    signal circular_buffer_reset : std_logic := '0';
    signal clk : std_logic := '0';
    signal binary_to_bcd_reset : std_logic := '0';
    signal bcd_out : std_logic_vector (39 downto 0) := (others => '0');
    signal bcd_out_expanded : std_logic_vector (31 downto 0) := (others => '0');
    signal alu_output : std_logic_vector (27 downto 0) := (others => '0');
    
    component alu is
        Port ( NUM_1_IN, NUM_2_IN, NUM_3_IN : in STD_LOGIC_VECTOR (27 downto 0);
               BUFFER_SIZE_IN, OPERATION_SELECT_IN : in STD_LOGIC_VECTOR (1 downto 0);
               OUTPUT_OUT : out STD_LOGIC_VECTOR (27 downto 0));
    end component alu;

    component circular_buffer is
        Port ( NUMBER_IN : in STD_LOGIC_VECTOR (27 downto 0);
               NUMBER_1_OUT, NUMBER_2_OUT, NUMBER_3_OUT : out STD_LOGIC_VECTOR (27 downto 0);
               BUFFER_SIZE_OUT : out STD_LOGIC_VECTOR (1 downto 0);
               RESET_IN, WRITE_TRIGGER_IN : in STD_LOGIC);
    end component circular_buffer;

    component binary_to_bcd_8 is
        Port ( CLK_IN : IN  std_logic;
               RESET_IN : IN  std_logic;
               BINARY_IN : IN  std_logic_vector(27 downto 0);
               BCD_8_DIGIT_OUT : OUT std_logic_vector (39 downto 0) := (others => '0'));
    end component binary_to_bcd_8;

begin
    ff0: alu port map ( NUM_1_IN => circular_buffer_output_1,
                        NUM_2_IN => circular_buffer_output_2,
                        NUM_3_IN => circular_buffer_output_3,
                        BUFFER_SIZE_IN => circular_buffer_size,
                        OPERATION_SELECT_IN => alu_operation_select,
                        OUTPUT_OUT => alu_output);
    
    ff1: circular_buffer port map ( NUMBER_IN => circular_buffer_input,
                                    NUMBER_1_OUT => circular_buffer_output_1,
                                    NUMBER_2_OUT => circular_buffer_output_2,
                                    NUMBER_3_OUT => circular_buffer_output_3,
                                    BUFFER_SIZE_OUT => circular_buffer_size,
                                    RESET_IN => circular_buffer_reset,
                                    WRITE_TRIGGER_IN => circular_buffer_write_trigger);

    ff2: binary_to_bcd_8 port map ( CLK_IN => clk,
                                    RESET_IN => binary_to_bcd_reset,
                                    BINARY_IN => alu_output,
                                    BCD_8_DIGIT_OUT => bcd_out);
    
    bcd_out_expanded(31 downto 28) <= bcd_out(38 downto 35);
    bcd_out_expanded(27 downto 24) <= bcd_out(33 downto 30);
    bcd_out_expanded(23 downto 20) <= bcd_out(28 downto 25);
    bcd_out_expanded(19 downto 16) <= bcd_out(23 downto 20);
    bcd_out_expanded(15 downto 12) <= bcd_out(18 downto 15);
    bcd_out_expanded(11 downto 8) <= bcd_out(13 downto 10);
    bcd_out_expanded(7 downto 4) <= bcd_out(8 downto 5);
    bcd_out_expanded(3 downto 0) <= bcd_out(3 downto 0);

    simulation_clk : process
    begin
        wait for 1ns;
        clk <= '1';
        wait for 1ns;
        clk <= '0';
    end process;
    
    simulation : process
    begin
        binary_to_bcd_reset <= '1';
        wait for 10ns;
        circular_buffer_reset <= '1';
        circular_buffer_input <= X"0000000";
        wait for 100ns;
        circular_buffer_reset <= '0';
        wait for 100ns;
        circular_buffer_input <= X"0010001";
        binary_to_bcd_reset <= '1';
        wait for 100ns;
        circular_buffer_write_trigger <= '1';
        wait for 100ns;
        circular_buffer_write_trigger <= '0';
        wait for 100ns;
        circular_buffer_input <= X"00FF000";
        wait for 10ns;
        circular_buffer_write_trigger <= '1';
        wait for 10ns;
        alu_operation_select <= "11";
        circular_buffer_write_trigger <= '0';
        wait for 100ns;
        circular_buffer_input <= X"0022222";
        wait for 10ns;
        circular_buffer_write_trigger <= '1';
        wait for 10ns;
        circular_buffer_write_trigger <= '0';
        wait for 100ns;
        binary_to_bcd_reset <= '0';
        wait for 100ns;
        binary_to_bcd_reset <= '1';
        alu_operation_select <= "01";
        wait for 1ns;
        binary_to_bcd_reset <= '0';
        wait for 100ns;
        binary_to_bcd_reset <= '1';
        alu_operation_select <= "10";
        wait for 100ns;
        binary_to_bcd_reset <= '0';
        wait for 200ns;
        circular_buffer_reset <= '1';
        wait for 100000ns;
    end process;

  \end{minted}
  \captionsetup{belowskip=0pt}
  \captionof{listing}{Testbench for ALU, circular buffer, and BCD to binary converter.}
  \label{code:alu_testbench}
\end{code}

\vspace*{1cm}

The waveform associated with the testbench in Listing \ref{code:alu_testbench} can be seen in Figure \ref{fig:alu_testbench_2}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{thing.jpeg}
  \caption{Reaction statistic calculation testbench.}
  \label{fig:alu_testbench_2}
\end{figure}

\end{document}

